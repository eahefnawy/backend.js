!(function(e) {
  if ('object' == typeof exports && 'undefined' != typeof module) module.exports = e()
  else if ('function' == typeof define && define.amd) define([], e)
  else {
    ;('undefined' != typeof window
      ? window
      : 'undefined' != typeof global
      ? global
      : 'undefined' != typeof self
      ? self
      : this
    ).backend = e()
  }
})(function() {
  var e,
    t,
    s = { exports: {} }
  ;(e = 'undefined' != typeof self ? self : this),
    (t = function(e) {
      'use strict'
      const t = new TextEncoder('utf-8'),
        s = {
          appstream2: 'appstream',
          cloudhsmv2: 'cloudhsm',
          email: 'ses',
          'git-codecommit': 'codecommit',
          marketplace: 'aws-marketplace',
          mobile: 'AWSMobileHubService',
          'mturk-requester-sandbox': 'mturk-requester',
          pinpoint: 'mobiletargeting',
          queue: 'sqs'
        },
        i = [
          'authorization',
          'content-type',
          'content-length',
          'user-agent',
          'presigned-expires',
          'expect',
          'x-amzn-trace-id'
        ]
      class n {
        constructor({
          method: e,
          url: t,
          headers: n,
          body: a,
          accessKeyId: r,
          secretAccessKey: o,
          sessionToken: c,
          service: h,
          region: d,
          cache: l,
          datetime: u,
          signQuery: p,
          appendSessionToken: g,
          allHeaders: y,
          singleEncode: m
        }) {
          if (null == t) throw new TypeError('url is a required option')
          if (null == r) throw new TypeError('accessKeyId is a required option')
          if (null == o) throw new TypeError('secretAccessKey is a required option')
          let f, w
          ;(this.method = e || (a ? 'POST' : 'GET')),
            (this.url = new URL(t)),
            (this.headers = new Headers(n)),
            (this.body = a),
            (this.accessKeyId = r),
            (this.secretAccessKey = o),
            (this.sessionToken = c),
            (h && d) ||
              ([f, w] = (function(e, t) {
                const { hostname: i, pathname: n } = e,
                  a = i
                    .replace('dualstack.', '')
                    .match(/([^.]+)\.(?:([^.]*)\.)?amazonaws\.com(?:\.cn)?$/)
                let [r, o] = (a || ['', '']).slice(1, 3)
                if ('us-gov' === o) o = 'us-gov-west-1'
                else if ('s3' === o || 's3-accelerate' === o) (o = 'us-east-1'), (r = 's3')
                else if ('iot' === r)
                  r = i.startsWith('iot.')
                    ? 'execute-api'
                    : i.startsWith('data.jobs.iot.')
                    ? 'iot-jobs-data'
                    : '/mqtt' === n
                    ? 'iotdevicegateway'
                    : 'iotdata'
                else if ('autoscaling' === r) {
                  const e = (t.get('X-Amz-Target') || '').split('.')[0]
                  'AnyScaleFrontendService' === e
                    ? (r = 'application-autoscaling')
                    : 'AnyScaleScalingPlannerFrontendService' === e && (r = 'autoscaling-plans')
                } else
                  null == o && r.startsWith('s3-')
                    ? ((o = r.slice(3).replace(/^fips-|^external-1/, '')), (r = 's3'))
                    : r.endsWith('-fips')
                    ? (r = r.slice(0, -5))
                    : o && /-\d$/.test(r) && !/-\d$/.test(o) && ([r, o] = [o, r])
                return [s[r] || r, o || 'us-east-1']
              })(this.url, this.headers)),
            (this.service = h || f),
            (this.region = d || w),
            (this.cache = l || new Map()),
            (this.datetime = u || new Date().toISOString().replace(/[:-]|\.\d{3}/g, '')),
            (this.signQuery = p),
            (this.appendSessionToken = g || 'iotdevicegateway' === this.service),
            this.headers.delete('Host')
          const A = this.signQuery ? this.url.searchParams : this.headers
          's3' !== this.service ||
            this.headers.has('X-Amz-Content-Sha256') ||
            this.headers.set('X-Amz-Content-Sha256', 'UNSIGNED-PAYLOAD'),
            A.set('X-Amz-Date', this.datetime),
            this.sessionToken &&
              !this.appendSessionToken &&
              A.set('X-Amz-Security-Token', this.sessionToken),
            (this.signableHeaders = ['host', ...this.headers.keys()]
              .filter((e) => y || !i.includes(e))
              .sort()),
            (this.signedHeaders = this.signableHeaders.join(';')),
            (this.canonicalHeaders = this.signableHeaders
              .map(
                (e) =>
                  e +
                  ':' +
                  ('host' === e ? this.url.host : this.headers.get(e).replace(/\s+/g, ' '))
              )
              .join('\n')),
            (this.credentialString = [
              this.datetime.slice(0, 8),
              this.region,
              this.service,
              'aws4_request'
            ].join('/')),
            this.signQuery &&
              ('s3' !== this.service || A.has('X-Amz-Expires') || A.set('X-Amz-Expires', 86400),
              A.set('X-Amz-Algorithm', 'AWS4-HMAC-SHA256'),
              A.set('X-Amz-Credential', this.accessKeyId + '/' + this.credentialString),
              A.set('X-Amz-SignedHeaders', this.signedHeaders)),
            (this.encodedPath =
              's3' === this.service
                ? decodeURIComponent(this.url.pathname)
                : this.url.pathname.replace(/\/+/g, '/')),
            m || (this.encodedPath = encodeURIComponent(this.encodedPath).replace(/%2F/g, '/'))
          const S = new Set()
          this.encodedSearch = [...this.url.searchParams]
            .filter(([e]) => {
              if (!e) return !1
              if ('s3' === this.service) {
                if (S.has(e)) return !1
                S.add(e)
              }
              return !0
            })
            .map((e) => e.map(encodeURIComponent).join('='))
            .sort()
            .join('&')
        }
        async sign() {
          return (
            this.signQuery
              ? (this.url.searchParams.set('X-Amz-Signature', await this.signature()),
                this.sessionToken &&
                  this.appendSessionToken &&
                  this.url.searchParams.set('X-Amz-Security-Token', this.sessionToken))
              : this.headers.set('Authorization', await this.authHeader()),
            { method: this.method, url: this.url, headers: this.headers, body: this.body }
          )
        }
        async authHeader() {
          return [
            'AWS4-HMAC-SHA256 Credential=' + this.accessKeyId + '/' + this.credentialString,
            'SignedHeaders=' + this.signedHeaders,
            'Signature=' + (await this.signature())
          ].join(', ')
        }
        async signature() {
          const e = this.datetime.slice(0, 8),
            t = [this.secretAccessKey, e, this.region, this.service].join()
          let s = this.cache.get(t)
          if (!s) {
            const i = await a('AWS4' + this.secretAccessKey, e),
              n = await a(i, this.region),
              r = await a(n, this.service)
            ;(s = await a(r, 'aws4_request')), this.cache.set(t, s)
          }
          return a(s, await this.stringToSign(), 'hex')
        }
        async stringToSign() {
          return [
            'AWS4-HMAC-SHA256',
            this.datetime,
            this.credentialString,
            await r(await this.canonicalString(), 'hex')
          ].join('\n')
        }
        async canonicalString() {
          return [
            this.method,
            c(this.encodedPath),
            c(this.encodedSearch),
            this.canonicalHeaders + '\n',
            this.signedHeaders,
            await this.hexBodyHash()
          ].join('\n')
        }
        async hexBodyHash() {
          return this.headers.has('X-Amz-Content-Sha256')
            ? this.headers.get('X-Amz-Content-Sha256')
            : r(this.body || '', 'hex')
        }
      }
      async function a(e, s, i) {
        const n = await crypto.subtle.importKey(
            'raw',
            'string' == typeof e ? t.encode(e) : e,
            { name: 'HMAC', hash: { name: 'SHA-256' } },
            !1,
            ['sign']
          ),
          a = await crypto.subtle.sign('HMAC', n, t.encode(s))
        return 'hex' === i ? o(a) : a
      }
      async function r(e, s) {
        const i = await crypto.subtle.digest('SHA-256', 'string' == typeof e ? t.encode(e) : e)
        return 'hex' === s ? o(i) : i
      }
      function o(e) {
        return Array.prototype.map
          .call(new Uint8Array(e), (e) => ('0' + e.toString(16)).slice(-2))
          .join('')
      }
      function c(e) {
        return e.replace(
          /[!'()*]/g,
          (e) =>
            '%' +
            e
              .charCodeAt(0)
              .toString(16)
              .toUpperCase()
        )
      }
      ;(e.AwsClient = class {
        constructor({
          accessKeyId: e,
          secretAccessKey: t,
          sessionToken: s,
          service: i,
          region: n,
          cache: a,
          retries: r,
          initRetryMs: o
        }) {
          if (null == e) throw new TypeError('accessKeyId is a required option')
          if (null == t) throw new TypeError('secretAccessKey is a required option')
          ;(this.accessKeyId = e),
            (this.secretAccessKey = t),
            (this.sessionToken = s),
            (this.service = i),
            (this.region = n),
            (this.cache = a || new Map()),
            (this.retries = null != r ? r : 10),
            (this.initRetryMs = o || 50)
        }
        async sign(e, t) {
          if (e instanceof Request) {
            const { method: s, url: i, headers: n, body: a } = e
            null == (t = Object.assign({ method: s, url: i, headers: n }, t)).body &&
              n.has('Content-Type') &&
              (t.body =
                null != a && n.has('X-Amz-Content-Sha256') ? a : await e.clone().arrayBuffer()),
              (e = i)
          }
          const s = new n(Object.assign({ url: e }, t, this, t && t.aws)),
            i = Object.assign({}, t, await s.sign())
          return delete i.aws, new Request(i.url, i)
        }
        async fetch(e, t) {
          for (let s = 0; s <= this.retries; s++) {
            const i = fetch(await this.sign(e, t))
            if (s === this.retries) return i
            const n = await i
            if (n.status < 500 && 429 !== n.status) return n
            await new Promise((e) =>
              setTimeout(e, Math.random() * this.initRetryMs * Math.pow(2, s))
            )
          }
        }
      }),
        Object.defineProperty(e, '__esModule', { value: !0 })
    }),
    'object' == typeof s.exports ? t(s.exports) : t((e.aws4fetch = {})),
    (s = s.exports)
  return (e) =>
    e.import.reduce(
      (t, i) => (
        (t[i] = async (t) =>
          (async (e, t, i = {}) => {
            const n = new s.AwsClient(e),
              a = `https://lambda.${e.region}.amazonaws.com/2015-03-31/functions`
            return (await n.fetch(`${a}/${t}/invocations`, { body: JSON.stringify(i) })).json()
          })(e, i, t)),
        t
      ),
      {}
    )
})
